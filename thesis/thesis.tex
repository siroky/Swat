\documentclass[12pt,a4paper]{report}
\setlength\textwidth{145mm}
\setlength\textheight{247mm}
\setlength\oddsidemargin{15mm}
\setlength\evensidemargin{15mm}
\setlength\topmargin{0mm}
\setlength\headsep{0mm}
\setlength\headheight{0mm}

\usepackage[utf8]{inputenc}
\usepackage{graphicx}
\usepackage{epstopdf}
\usepackage{amsthm}
\usepackage{appendix}
\usepackage{nomencl}
\usepackage{parskip}

\makenomenclature

% Less indented chapter titles.
\makeatletter
\def\@makechapterhead#1{
  {\parindent \z@ \raggedright \normalfont
   \Huge\bfseries \thechapter. #1
   \par\nobreak
   \vskip 20\p@
}}
\def\@makeschapterhead#1{
  {\parindent \z@ \raggedright \normalfont
   \Huge\bfseries #1
   \par\nobreak
   \vskip 20\p@
}}
\makeatother

% Chapter without a number but still in the table of contents.
\def\chapwithtoc#1{
\chapter*{#1}
\addcontentsline{toc}{chapter}{#1}
}

\begin{document}

\lefthyphenmin=2
\righthyphenmin=2



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\pagestyle{empty}

\begin{center}
\large Charles University in Prague
\medskip

Faculty of Mathematics and Physics

\vfill

{\bf\Large MASTER THESIS}

\vfill

\centerline{\mbox{\includegraphics[width=60mm]{img/logo.eps}}}

\vfill

\vspace{5mm}

{\LARGE Jan Široký}

\vspace{15mm}

{\LARGE\bfseries Scala Web Application Toolkit}

\vfill

Department of Distributed and Dependable Systems

\vfill

\begin{tabular}{rl}
Supervisor of the master thesis: & Pavel Ježek \\
\noalign{\vspace{2mm}}
Study programme: & Computer Science \\
\noalign{\vspace{2mm}}
Specialization: & Software Systems \\
\end{tabular}

\vfill

Prague 2013
\end{center}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
\noindent 
Dedication.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage

\vglue 0pt plus 1fill
\noindent
I declare that I carried out this master thesis independently, and only with the cited sources, literature and other professional sources.

\medskip\noindent
I understand that my work relates to the rights and obligations under the Act No. 121/2000 Coll., the Copyright Act, as amended, in particular the fact that the Charles University in Prague has the right to conclude a license agreement on the use of this work as a school work pursuant to Section 60 paragraph 1 of the Copyright Act.

\vspace{10mm}
\hbox{\hbox to 0.5\hsize{%
In ........ date ............
\hss}\hbox to 0.5\hsize{%
signature of the author
\hss}}
\vspace{20mm}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage

\vbox to 0.5\vsize{
\setlength\parindent{0mm}
\setlength\parskip{5mm}

Název práce: 
Scala Web Application Toolkit

Autor: 
Jan Široký

Katedra: 
Katedra distribuovaných a spolehlivých systémů

Vedoucí diplomové práce: 
Mgr. Pavel Ježek Ph.D, Katedra distribuovaných a spolehlivých systémů

Abstrakt:
TODO

Klíčová slova:
Scala, JavaScript, RIA, JSON, RPC

\vss}\nobreak\vbox to 0.49\vsize{
\setlength\parindent{0mm}
\setlength\parskip{5mm}

Title:
Scala Web Application Toolkit

Author:
Jan Široký

Department:
Department of Distributed and Dependable Systems

Supervisor:
Mgr. Pavel Ježek Ph.D, Department of Distributed and Dependable Systems

Abstract:
TODO

Keywords:
Scala, JavaScript, RIA, JSON, RPC

\vss}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
\pagestyle{plain}
\setcounter{page}{1}
\tableofcontents



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Introduction}

The environment of websites and web applications has been rapidly evolving and going through a lot of changes for the last twenty years. It may even be considered the most dynamic area of software development, currently together with mobile application development. The first websites were just static HTML pages linked together with anchors. But people soon found out it's possible to generate the pages on the server, thus provide a dynamic behavior and mimic standard desktop applications. The obvious drawback is that after every action of the user, the whole page has to be reloaded. 

In order to mitigate the problems of dynamic pages, new browser based technologies started to emerge, the most known are Flash, Java Applets and JavaScript. The proprietary Flash and Java Applets were designed solely for the purpose of web application development, JavaScript was in the first phases meant as a simple scripting language for manipulation with the page. However with the ability to send HTTP requests (known as AJAX), it turned out that JavaScript may be even used as a platform for web applications. 

The current tendency is to move from the proprietary technologies to JavaScript, which is widely supported by browsers and devices. With the new HTML5 specifications, which are being adopted quite quickly by the major browsers, even the advantages of other technologies (e.g. video in Flash) are disappearing. So a growing number of web applications is in the moment designed as a single HTML page with embedded JavaScript that takes care of everything. And the single page is backed by a server API that the client JavaScript communicates with. This architecture is actually quite similar to the desktop applications, so design patterns and techniques that are already proven-right from the desktop environment may be utilized. From the architectural point of view, the web and desktop application branches are merging.

During past couple of years, JavaScript has been used so extensively, that developers started to reach its limits in modularization and maintainability, mainly while working on big applications. Other programming languages however handle those issues better and because JavaScript is a rather powerful programming language, it's not that difficult to use it as a compilation target for those languages. Even completely new programming languages with the only purpose to improve JavaScript appeared, so currently there is more than one hundred of languages that compile to JavaScript\cite{backends}, both new and mainstream like Java, C\#, C++ etc.

\section{Motivation}

The vast amount of compilers targetting JavaScript suggests, there actually are objective reasons and motivation behind them, which drive their development efforts. And because compilation is a development step, that isn't present while writing plain JavaScript programs, the motivation has to be strong enough, so programmers are willing to bear this additional step. The following sections should summarize the main disadvantages of JavaScript and briefly describe current trends in the field of JavaScript improving and compilation to it.

\subsection{JavaScript Disadvantages}

When evaluating a programming language, it's always necessary to specify the context of its usage. Here, we're interested in the area of large and complex web applications, so it doesn't mean that JavaScript shouldn't be used for small and even middle-sized applications.

\paragraph{Language} The JavaScript itself is a dynamically typed language with prototype-based inheritance, which is rather different from the mainstream enterprise languages. It has no notion of classes, modules, packages or any other such concepts. The whole program consists of bunch of functions and nested objects, which are all accessible from the global scope, due to the fact that object is a key-value table without any access modifiers. There also isn't any way how to define interface and its implementation, so it's impossible to hide the complexity of components behind interfaces. All this leads to a drawback, that JavaScript programs are difficult to modularize. Advantages of static typing over dynamic typing are nicely summarized in \cite{meijer} as: 

\begin{quote}
"...earlier detection of programming mistakes (e.g. preventing adding an integer to a boolean), better documentation in the form of type signatures (e.g. incorporating number and types of arguments when resolving names), more opportunities for compiler optimizations (e.g. replacing virtual calls by direct calls when the exact type of the receiver is known statically), increased runtime efficiency (e.g. not all values need to carry a dynamic type), and a better design time developer experience (e.g. knowing the type of the receiver, the IDE can present a drop-down menu of all applicable members)."
\end{quote}

Even though inheritance is present in JavaScript, its very different from the class-based inheritance most of the programmers are used to, so it takes some time to fully understand it and take advantage of it. The JavaScript community realizes some of the disadvantages and tries to remedy them on the language level using sometimes peculiar constructs, but there is no standardized or widely adopted way so those efforts stay in the position of suggested conventions.

\paragraph{Distribution} The most common way of library distribution is one big JavaScript file containing everything. Therefore when a fraction of a library is used, the whole library has to be loaded into the page. And dependencies among the libraries are described in the documentation, so an absence of dependency causes runtime error claiming that a function or an object is undefined. This leads to an environment where the libraries are more likely monolithic and don't share the common functionality even if they could. Similar problem arises when the single application is subdivided into multiple source files. Then all the files have to be declared in the page using script elements in their dependency order. There already exist loaders that handle packaging (RequireJS, HeadJS) but all share the common disadvantage that the organization od source files into modules and dependencies among them have to be explicitly declared.

\paragraph{Development process} As a consequence of the dynamic typing, some of the automatic development tools aren't as powerful as in statically typed languages or are even unusable. Code analyzers and optimizers from the principle can't do that much, but there are couple of such tools (JSLint, JSHint, Google Closure Compiler). Automatic refactoring can't be utilized at all, so in real life it boils down to unreliable operation "replace in files". Intellisense in IDEs is currently at least partially usable however still far behind statically typed languages. Hand in hand with intellisense comes the source documentation in form of documentation comments, because when it doesn't pop up in the IDE, programmers are less motivated to write it.

\subsection{Improving JavaScript}

To sort out most of the aforementioned language issues, it's basically enough to use a programming language with static (or at least optionally static) type system, packages, classes, interfaces and access modifiers, allow the developers to write programs in that languages and compile them into JavaScript. Consequently the development process issues disappear too. Ideally the source language should be much more expressive than JavaScript, no only small superset in terms of language features, so the compilation step really pays off. Similarly to the step from assembler to C. 

\paragraph{New languages} One branch of the improvement process leads to design of new programming languages solely with the purpose to extend JavaScript. The most well-known examples are Dart, CoffeeScript and TypeScript. Their advantage is that they're designed with the knowledge that programs would be compiled to JavaScript, so for example primitive types don't deviate from JavaScript primitive types and some of them allow optional typing which is good for interoperation with existing libraries. Another benefit is, that from the syntax point of view, they're mostly quite similar to JavaScript so the learning curve is steep for established web application developers. On the other hand, the fact they're brand new implies, that for the whole application, one has to be familiar with three programming languages at a time (one for server side, the new language and JavaScript). The type systems of those languages aren't that complex and their expressiveness is rather close to JavaScript, therefore the improvement isn't as big as it theoretically could be. Dart is however the farthest one in that direction.

\paragraph{Existing languages} The more appealing idea is to use existing proven language and add the JavaScript backend to its compiler. And if the language is well-suited for web applications or APIs, then even better, because the two ultimate aims could be accomplished: having the whole application written in one language and code-sharing and reuse between server-side and client-side.\footnote{These goals are so attractive, that the project Node.js tackles them from the other side by enabling usage of JavaScript on the servers.} With this setup, even things like remote method invocation are possible. Drawback is that the languages differ from JavaScript a lot, interoperation with it is more inconvenient and in some cases, they're less expressive than JavaScript (e.g. lack of closures in Java). The most famous representatives of this branch are Google Web Toolkit for Java and SharpKit for C\#, but almost all established languages have their JavaScript compilers.

\subsection{Why Scala}

During development of one web application in Scala, whose big part should run in the web browser, it was decided that it would be nice to implement that part using something like GWT, just for Scala. However no such tool turned out to be both usable, maintained and not abandoned. That lead to an origin of the project to implement such a tool for Scala. Later it emerged that it'd be more likely a set of tools, therefore the name of the project and also title of this thesis converged to "Scala Web Application Toolkit".

Scala is relatively new, yet already established programming language. Among the family of modern programming languages that run on top of JVM (Groovy, Clojure, Kotlin) it's the most popular one according to TIOBE as of writing this thesis, currently gaining a lot of momentum and being already adopted by commercial companies like Twitter or LinkedIn. Moreover it's backed by strong academic community, so the language with all the concepts and paradigms are well thought through. All these facts determined that it'd be good idea to start the project, because there's a possibility for a lot of potential.

\section{Goals}

\subsection{Core}

\begin{itemize}
\item Compile from Scala to JavaScript
\item Easily interoperate with JavaScript APIs and libraries.
\item Enable code reuse by embracing usage of standard Java and Scala library.
\item Provide runtime support if needed.
\item Simple distribution of libraries (both Scala and JavaScript together). 
\end{itemize}

\subsection{Enhancements}

In principle could do without them, but bring more comfort to the further development.

\begin{itemize}
\item Loader that can load compiled JavaScript files from the server on the fly.
\item JSON serializer \& deserializer (usable not only for Scala $\leftrightarrow$ JavaScript communication).
\item RPC.
\end{itemize}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Background}

Both Scala and JavaScript aren't mainstream languages in the sense of chosen paradigms and used concepts, so the following sections will focus mainly on the differences form the conventional languages (C++, Java, C\#) and on differences between the two, which are important from the compiler perspective.

\section{JavaScript}

\begin{itemize}
\item Scripting, object-oriented, imperative, functional, dynamic type system, interpreted. 
\item Prototype-based OOP.
\item Scoping.
\end{itemize}

\section{Scala}

\begin{itemize}
\item Functional, object-oriented, imperative, concurrent, type system is static, strong, inferred. Compiled to Java bytecode. With strong academic background.
\item Unified type system, type inference, everything is an expression, syntactic flexibility thus suitable for DSLs.
\item Full support for functional programming (currying, pattern matching, algebraic data types, lazy evaluation, tail recursion, immutability, etc.).
\item Rich OOP - Classes, traits, singleton objects, multiple inheritance (using linearization), classes and abstract types as object members, expressive type system (structural types, path-dependent types, generics + variance annotations, upper and lower type bounds.
\end{itemize}

\subsection{Compiler Architecture}

https://wiki.scala-lang.org/display/SIW/Compiler
http://lampwww.epfl.ch/~odersky/papers/ScalableComponent.pdf

\begin{itemize}
\item Compiler architecture overview.
\item Compiler phases, pluggability.
\end{itemize}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Analysis}

This chapter shouldn't be somewhat biased by the fact, that the source language is Scala. The accent should be on how to transpose particular higher-level language concepts to JavaScript equivalent and how to solve related issues. So it should be applicable in different languages.

\section{Setup}

\begin{itemize}
\item Plugging into compiler vs. extending and modifying it (in order to reorder and exclude phases). Suggested architecture (Source language AST $\rightarrow$ Compilation $\rightarrow$ JS AST $\rightarrow$ possibly other phases (not used in Swat) $\rightarrow$ ... $\rightarrow$ JS Code Gen $\rightarrow$ possibly other tools applied on the resulting JS, e.g. Google Closure compiler). 
\item Choice of phase, after which the JavaScript compilation runs, highly determines the resulting code and also the need of runtime support. Swat decided to run in a point when the Scala ASTs most resemble JavaScript, even though it's not the most simple way to go and also causes some runtime overhead. The motivation behind it is to simplify debugging.
\end{itemize}

\section{Interoperation with JavaScript}

Has to be compatible with standard Scala Compiler so it won't fail before the custom plugin. Two ways how to solve it: 
\begin{itemize}
\item Using dynamic.
\item Strongly typed adapters and why they're better.
\end{itemize}

\section{Compilation}

The compiler starts given the whole program (or its top level part) in form of an AST. It's natural to start with the top-level ASTs that encapsulate everything else and go down the tree through class definitions, their member definitions to expressions on the bottom of the tree.

\subsection{Scope of a Compilation Unit}

\begin{itemize}
\item Extracting so called types (classes, traits, objects) from the compilation unit.
\item Compiling the types separately, while tracking dependencies (two different kinds) among them.
\item Inheritance, solving static initialization order, encoding type information.
\item Producing type files which form an oriented dependency graph.
\end{itemize}

\subsection{Scope of a Type}

\begin{itemize}
\item Extracting members.
\item Processing fields, nothing has to be declared in JS, therefore setting initial values in constructor is enough, lazy fields.
\item Processing methods, taking care of overloading and constructor.
\end{itemize}

\subsection{Expression Scope}

\begin{itemize}
\item Scoping, var self = this.
\item Primitive types, their representation in JavaScript, decision not to extend JavaScript built-in objects, primitive type methods as extension methods or operators.
\item Anonymous functions, partial functions.
\item Method invocation, super call, this call, Any type methods as internal swat methods.
\item Local methods and types.
\item Control structures.
\end{itemize}

\section{Library Distribution}

Storing the compiled JavaScript files as resources of the very same module, so they're included in the packaged jar together with the Java classfiles. Integration of such library and using it on both platforms is therefore simple. Implies need of a type loader, that can access the type files.

\section{Runtime}

The only interesting thing, from the analysis point of view, is encoding class/trait inheritance in JavaScript using the object prototype chaining.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%





%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Implementation}

\section{Environment}

Prerequisities, Scala, versions, build tools.

\section{Project Overview}

The big picture of the whole project, interaction of all components and description of the processes in it so one can get understanding of how the whole thing works, including the type loading, RPC and JSON serializers.

\section{API \& Adapters}

Description of the annotations: ignored, adapter, native, dependency. Walkthrough (or rather example) on how to create adapters without the necessity to blindly copy the specification using traits as shared interfaces.

\section{Compiler}

Basically a big match against all types of Scala ASTs that follows the principles described in analysis.

\subsection{Build Process}

Integration to SBT.

\section{Runtime}

\subsection{Client}

Description of everything intereseting in the swat.js.

\subsection{Standard Libraries}

Lazy approach, modifying the sources to exclude parts not relevant in the JavaScript environment. The purpose is not to blindly port everything but rather only a portion which is usable in JavaScript.

\subsection{Type Loader}

How it works on the server side and how on the client side.

\subsection{JSON Serializer}

The format that enables us to serialize even graphs of objects with cyclic references. Including type information in order to succesfully deserialize on the server and assign proper prototype on the client.

\subsection{RPC}

Support from the compiler, thin client proxy and server dispatcher. Only non-blocking, utilizing Scala Futures and Promises, exception handling.

\section{Integration with a Web Framework}

Should be as simple as possible, Play Framework example.

\section{Tests}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Comparison with Similar Tools}

The tools at the time of thesis start (ScalaGWT, s2js, scalosure) and current scala-js, js-scala.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Conclusion}

\section{Critical Evaluation}

What was done, what lacks the most (Scala library), but stating that everything got done to some extent. Discussion about the overloading problem and the taken decision.

\section{Roadmap}

Actually the main purpose and goal is to really simplify tasks, that aren't programmer friendly in JavaScript. The grounds have been laid, so the really interesting applications can be now implemented. Some of the interesting directions are described in the following sections.

\subsection{Web workers}

Actor like abstraction over web workers, with help of JSON serializer and type-loader.

\subsection{Template engine}

Problems with JavaScript templating and how it could be solved using string interpolation.

\subsection{Build process}

Swat as a SBT plugin, resident compilation that would simplify the development process.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\def\bibname{Bibliography}
\begin{thebibliography}{99}
\addcontentsline{toc}{chapter}{\bibname}

\bibitem{backends}
  {\sc Ashkenas,} Jeremy.
  \emph{List of languages that compile to JS}.
  https://github.com/jashkenas/coffee-script/wiki/List-of-languages-that-compile-to-JS
	
\bibitem{meijer}
	{\sc Meijer,} Erik and {\sc Drayton,} Peter.
	\emph{Static Typing Where Possible, Dynamic Typing When Needed: The End of the Cold War Between Programming Languages}.
	http://research.microsoft.com/en-us/um/people/emeijer/Papers/RDL04Meijer.pdf

\end{thebibliography}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\appendix
\appendixpage
\addappheadtotoc

\chapter{User Manual}

\chapter{Sample Application}

A nice example could be online SWAT compiler, that would let the user write some Scala code to a textarea, invoke the Swat compiler (through RPC on the server) and display the compiler code.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Content of attached CD}





\printnomenclature




\end{document}
