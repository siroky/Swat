\documentclass[12pt,a4paper]{report}
\setlength\textwidth{145mm}
\setlength\textheight{247mm}
\setlength\oddsidemargin{15mm}
\setlength\evensidemargin{15mm}
\setlength\topmargin{0mm}
\setlength\headsep{0mm}
\setlength\headheight{0mm}

\usepackage[utf8]{inputenc}
\usepackage{graphicx}
\usepackage{epstopdf}
\usepackage{amsthm}
\usepackage{appendix}
\usepackage{nomencl}

\makenomenclature

% Less indented chapter titles.
\makeatletter
\def\@makechapterhead#1{
  {\parindent \z@ \raggedright \normalfont
   \Huge\bfseries \thechapter. #1
   \par\nobreak
   \vskip 20\p@
}}
\def\@makeschapterhead#1{
  {\parindent \z@ \raggedright \normalfont
   \Huge\bfseries #1
   \par\nobreak
   \vskip 20\p@
}}
\makeatother

% Chapter without a number but still in the table of contents.
\def\chapwithtoc#1{
\chapter*{#1}
\addcontentsline{toc}{chapter}{#1}
}

\begin{document}

\lefthyphenmin=2
\righthyphenmin=2



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\pagestyle{empty}

\begin{center}
\large Charles University in Prague
\medskip

Faculty of Mathematics and Physics

\vfill

{\bf\Large MASTER THESIS}

\vfill

\centerline{\mbox{\includegraphics[width=60mm]{img/logo.eps}}}

\vfill

\vspace{5mm}

{\LARGE Jan Široký}

\vspace{15mm}

{\LARGE\bfseries Scala Web Application Toolkit}

\vfill

Department of Distributed and Dependable Systems

\vfill

\begin{tabular}{rl}
Supervisor of the master thesis: & Pavel Ježek \\
\noalign{\vspace{2mm}}
Study programme: & Computer Science \\
\noalign{\vspace{2mm}}
Specialization: & Software Systems \\
\end{tabular}

\vfill

Prague 2013
\end{center}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
\noindent 
Dedication.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage

\vglue 0pt plus 1fill
\noindent
I declare that I carried out this master thesis independently, and only with the cited sources, literature and other professional sources.

\medskip\noindent
I understand that my work relates to the rights and obligations under the Act No. 121/2000 Coll., the Copyright Act, as amended, in particular the fact that the Charles University in Prague has the right to conclude a license agreement on the use of this work as a school work pursuant to Section 60 paragraph 1 of the Copyright Act.

\vspace{10mm}
\hbox{\hbox to 0.5\hsize{%
In ........ date ............
\hss}\hbox to 0.5\hsize{%
signature of the author
\hss}}
\vspace{20mm}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage

\vbox to 0.5\vsize{
\setlength\parindent{0mm}
\setlength\parskip{5mm}

Název práce: 
Scala Web Application Toolkit

Autor: 
Jan Široký

Katedra: 
Katedra distribuovaných a spolehlivých systémů

Vedoucí diplomové práce: 
Mgr. Pavel Ježek Ph.D, Katedra distribuovaných a spolehlivých systémů

Abstrakt:
TODO

Klíčová slova:
Scala, JavaScript, RIA, JSON, RPC

\vss}\nobreak\vbox to 0.49\vsize{
\setlength\parindent{0mm}
\setlength\parskip{5mm}

Title:
Scala Web Application Toolkit

Author:
Jan Široký

Department:
Department of Distributed and Dependable Systems

Supervisor:
Mgr. Pavel Ježek Ph.D, Department of Distributed and Dependable Systems

Abstract:
TODO

Keywords:
Scala, JavaScript, RIA, JSON, RPC

\vss}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
\pagestyle{plain}
\setcounter{page}{1}
\tableofcontents



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Introduction}

\begin{itemize}
\item Movement (or rather new branch) in the web application area from dynamic pages generated by the server to JavaScript applications that use server APIs. Multipage applications turn to single page applications.
\item Tendency in past couple of years to compile into JavaScript. JavaScript starts to become the assembler of the web.
\end{itemize}

\section{Motivation}

\begin{itemize}
\item Disadvantages of JavaScript in the context of larger applications (lack of packaging, everything is accessible, prototype based OOP, dynamic typing, everything has to be in documentation or comments).
\item Disadvantages of JavaScript development tools (refactoring, code analysis, intellisense).
\item Adding packages, classes and static type system (sometimes optional) to JS solves most of the problems. Examples of some languages that improve JavaScript - CoffeeScript, Dart, TypeScript, but they're completely new languages, so one has to learn not only JS, but also them.
\item Using an existing language that would mitigate the JavaScript disadvantages seems reasonable. Moreover it brings code-sharing and reuse of existing code. Possibility to write whole application together with the server-side in one language (the motiviation behind Node.js). GWT in the Java world, Script\# or SharpKit in the C\# world, and corresponding tools in other languages.
\item Scala is nice, new and perspective, currently gaining a lot of momentum and being adopted by commercial companies (Twitter, LinkedIn) so it has been chosen as the source language.
\end{itemize}

\section{Goals}

\subsection{Core}

\begin{itemize}
\item Compile from Scala to JavaScript
\item Easily interoperate with JavaScript APIs and libraries.
\item Enable code reuse by embracing usage of standard Java and Scala library.
\item Provide runtime support if needed.
\item Simple distribution of libraries (both Scala and JavaScript together). 
\end{itemize}

\subsection{Enhancements}

In principle could do without them, but bring more comfort to the further development.

\begin{itemize}
\item Loader that can load compiled JavaScript files from the server on the fly.
\item JSON serializer \& deserializer (usable not only for Scala $\leftrightarrow$ JavaScript communication).
\item RPC.
\end{itemize}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Background}

Both Scala and JavaScript aren't mainstream languages in the sense of chosen paradigms and used concepts, so the following sections will focus mainly on the differences form the conventional languages (C++, Java, C\#) and on differences between the two, which are important from the compiler perspective.

\section{JavaScript}

\begin{itemize}
\item Scripting, object-oriented, imperative, functional, dynamic type system, interpreted. 
\item Prototype-based OOP.
\item Scoping.
\end{itemize}

\section{Scala}

\begin{itemize}
\item Functional, object-oriented, imperative, concurrent, type system is static, strong, inferred. Compiled to Java bytecode. With strong academic background.
\item Unified type system, type inference, everything is an expression, syntactic flexibility thus suitable for DSLs.
\item Full support for functional programming (currying, pattern matching, algebraic data types, lazy evaluation, tail recursion, immutability, etc.).
\item Rich OOP - Classes, traits, singleton objects, multiple inheritance (using linearization), classes and abstract types as object members, expressive type system (structural types, path-dependent types, generics + variance annotations, upper and lower type bounds.
\end{itemize}

\subsection{Compiler Architecture}

https://wiki.scala-lang.org/display/SIW/Compiler
http://lampwww.epfl.ch/~odersky/papers/ScalableComponent.pdf

\begin{itemize}
\item Compiler architecture overview.
\item Compiler phases, pluggability.
\end{itemize}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Analysis}

This chapter shouldn't be somewhat biased by the fact, that the source language is Scala. The accent should be on how to transpose particular higher-level language concepts to JavaScript equivalent and how to solve related issues. So it should be applicable in different languages.

\section{Setup}

\begin{itemize}
\item Plugging into compiler vs. extending and modifying it (in order to reorder and exclude phases). Suggested architecture (Source language AST $\rightarrow$ Compilation $\rightarrow$ JS AST $\rightarrow$ possibly other phases (not used in Swat) $\rightarrow$ ... $\rightarrow$ JS Code Gen $\rightarrow$ possibly other tools applied on the resulting JS, e.g. Google Closure compiler). 
\item Choice of phase, after which the JavaScript compilation runs, highly determines the resulting code and also the need of runtime support. Swat decided to run in a point when the Scala ASTs most resemble JavaScript, even though it's not the most simple way to go and also causes some runtime overhead. The motivation behind it is to simplify debugging.
\end{itemize}

\section{Interoperation with JavaScript}

Has to be compatible with standard Scala Compiler so it won't fail before the custom plugin. Two ways how to solve it: 
\begin{itemize}
\item Using dynamic.
\item Strongly typed adapters and why they're better.
\end{itemize}

\section{Compilation}

The compiler starts given the whole program (or its top level part) in form of an AST. It's natural to start with the top-level ASTs that encapsulate everything else and go down the tree through class definitions, their member definitions to expressions on the bottom of the tree.

\subsection{Scope of a Compilation Unit}

\begin{itemize}
\item Extracting so called types (classes, traits, objects) from the compilation unit.
\item Compiling the types separately, while tracking dependencies (two different kinds) among them.
\item Inheritance, solving static initialization order, encoding type information.
\item Producing type files which form an oriented dependency graph.
\end{itemize}

\subsection{Scope of a Type}

\begin{itemize}
\item Extracting members.
\item Processing fields, nothing has to be declared in JS, therefore setting initial values in constructor is enough, lazy fields.
\item Processing methods, taking care of overloading and constructor.
\end{itemize}

\subsection{Expression Scope}

\begin{itemize}
\item Scoping, var self = this.
\item Primitive types, their representation in JavaScript, decision not to extend JavaScript built-in objects, primitive type methods as extension methods or operators.
\item Anonymous functions, partial functions.
\item Method invocation, super call, this call, Any type methods as internal swat methods.
\item Local methods and types.
\item Control structures.
\end{itemize}

\section{Library Distribution}

Storing the compiled JavaScript files as resources of the very same module, so they're included in the packaged jar together with the Java classfiles. Integration of such library and using it on both platforms is therefore simple. Implies need of a type loader, that can access the type files.

\section{Runtime}

The only interesting thing, from the analysis point of view, is encoding class/trait inheritance in JavaScript using the object prototype chaining.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Project Overview}

The big picture of the whole project, interaction of all components and description of the processes in it so one can get understanding of how the whole thing works, including the type loading, RPC and JSON serializers.




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Implementation}

\section{API \& Adapters}

Description of the annotations: ignored, adapter, native, dependency. Walkthrough (or rather example) on how to create adapters without the necessity to blindly copy the specification using traits as shared interfaces.

\section{Compiler}

Basically a big match against all types of Scala ASTs that follows the principles described in analysis.

\subsection{Build Process}

Integration to SBT.

\section{Runtime}

\subsection{Client}

Description of everything intereseting in the swat.js.

\subsection{Standard Libraries}

Lazy approach, modifying the sources to exclude parts not relevant in the JavaScript environment. The purpose is not to blindly port everything but rather only a portion which is usable in JavaScript.

\subsection{Type Loader}

How it works on the server side and how on the client side.

\subsection{JSON Serializer}

The format that enables us to serialize even graphs of objects with cyclic references. Including type information in order to succesfully deserialize on the server and assign proper prototype on the client.

\subsection{RPC}

Support from the compiler, thin client proxy and server dispatcher. Only non-blocking, utilizing Scala Futures and Promises, exception handling.

\section{Integration with a Web Framework}

Should be as simple as possible, Play Framework example.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Comparison with Similar Tools}

The tools at the time of thesis start (ScalaGWT, s2js, scalosure) and current scala-js, js-scala.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Conclusion}

\section{Critical Evaluation}

What was done, what lacks the most (Scala library), but stating that everything got done to some extent. Discussion about the overloading problem and the taken decision.

\section{Roadmap}

Actually the main purpose and goal is to really simplify tasks, that aren't programmer friendly in JavaScript. The grounds have been laid, so the really interesting applications can be now implemented. Some of the interesting directions are described in the following sections.

\subsection{Web workers}

Actor like abstraction over web workers, with help of JSON serializer and type-loader.

\subsection{Template engine}

Problems with JavaScript templating and how it could be solved using string interpolation.

\subsection{Build process}

Swat as a SBT plugin, resident compilation that would simplify the development process.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\def\bibname{Bibliography}
\begin{thebibliography}{99}
\addcontentsline{toc}{chapter}{\bibname}

%\bibitem{lamport94}
%  {\sc Lamport,} Leslie.
%  \emph{\LaTeX: A Document Preparation System}.
%  2. vydání.
%  Massachusetts: Addison Wesley, 1994.
%  ISBN 0-201-52983-1.

\end{thebibliography}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\appendix
\appendixpage
\addappheadtotoc
\chapter{Sample Application}

A nice example could be online SWAT compiler, that would let the user write some Scala code to a textarea, invoke the Swat compiler (through RPC on the server) and display the compiler code.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Developer Manual}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Content of attached CD}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{List of Tables}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{List of Abbreviations}

\printnomenclature




\end{document}
